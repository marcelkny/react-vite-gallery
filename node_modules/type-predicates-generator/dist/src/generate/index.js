"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const glob = require("glob");
const typescript_1 = require("typescript");
const compiler_api_handler_1 = require("../compiler-api/compiler-api-handler");
const program_1 = require("../compiler-api/program");
const generate_type_predicates_1 = require("../generate/generate-type-predicates");
const utils_1 = require("../utils");
async function run({ tsconfigPath, fileGlobs, output, basePath, option, }) {
    const files = fileGlobs
        .flatMap((fileGlob) => glob.sync(fileGlob, {
        sync: true,
        cwd: basePath,
        ignore: ["**/node_modules/**/*.ts", output],
    }))
        .map((filePath) => (0, path_1.resolve)(basePath, filePath))
        .filter((filePath) => filePath !== output);
    let program;
    if (option.watch) {
        let onUpdate = undefined;
        const watcher = (0, program_1.watchCompiler)(tsconfigPath, files, () => {
            if (onUpdate) {
                onUpdate();
            }
        }, {
            watchFile: typescript_1.WatchFileKind.UseFsEvents,
            excludeFiles: [output],
        }, 
        // デフォルトのメソッドを打ち消すため
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        () => { }, 
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        () => { });
        onUpdate = () => {
            const updatedProgram = watcher.getProgram().getProgram();
            generateAndWriteCodes(updatedProgram, files, output, option);
            console.log("File changes are detected, and successfully regenerated.");
        };
        program = watcher.getProgram().getProgram();
        console.log("start watching ...");
    }
    else {
        program = (0, program_1.createProgram)(tsconfigPath);
    }
    generateAndWriteCodes(program, files, output, option);
    console.log(`successfully generated: ${output}`);
}
exports.run = run;
const generateAndWriteCodes = (program, files, output, { asserts, defaultArrayCheckOption, comment, whitelist }) => {
    const handler = new compiler_api_handler_1.CompilerApiHandler(program);
    const types = files.map((filePath) => {
        const result = handler.extractTypes(filePath);
        const importPath = "./" +
            (0, path_1.relative)((0, path_1.resolve)(output, ".."), filePath)
                .replace(".d.ts", "")
                .replace(".ts", "");
        if ((0, utils_1.isNg)(result)) {
            throw Error(`Fail to extract types from ${filePath}`);
        }
        return {
            importPath,
            types: result.ok.filter((type) => typeof type.typeName === "string"),
        };
    });
    const generatedCode = (0, generate_type_predicates_1.generateTypePredicates)(types, asserts, defaultArrayCheckOption, comment, whitelist);
    (0, fs_1.writeFileSync)(output, generatedCode);
};
