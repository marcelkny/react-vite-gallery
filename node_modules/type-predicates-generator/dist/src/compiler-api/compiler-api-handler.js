"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CompilerApiHandler_instances, _CompilerApiHandler_program, _CompilerApiHandler_typeChecker, _CompilerApiHandler_extractTypesFromExportDeclaration, _CompilerApiHandler_extractNodes, _CompilerApiHandler_createObjectType, _CompilerApiHandler_extractArrayTFromTypeNode, _CompilerApiHandler_extractArrayT, _CompilerApiHandler_extractTypeArguments, _CompilerApiHandler_extractTypeArgumentsFromTypeRefNode, _CompilerApiHandler_hasUnresolvedTypeParameter, _CompilerApiHandler_convertType, _CompilerApiHandler_isCallable, _CompilerApiHandler_getMembers, _CompilerApiHandler_isTypeParametersResolved, _CompilerApiHandler_typeToString;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompilerApiHandler = void 0;
const ts = require("typescript");
const typescript_1 = require("typescript");
const utils_1 = require("../utils");
const utils_2 = require("../utils");
const type_object_1 = require("../type-object");
class CompilerApiHandler {
    constructor(program) {
        _CompilerApiHandler_instances.add(this);
        _CompilerApiHandler_program.set(this, void 0);
        _CompilerApiHandler_typeChecker.set(this, void 0);
        __classPrivateFieldSet(this, _CompilerApiHandler_program, program, "f");
        __classPrivateFieldSet(this, _CompilerApiHandler_typeChecker, __classPrivateFieldGet(this, _CompilerApiHandler_program, "f").getTypeChecker(), "f");
    }
    extractTypes(filePath) {
        const sourceFile = __classPrivateFieldGet(this, _CompilerApiHandler_program, "f").getSourceFile(filePath);
        if (!sourceFile) {
            return (0, utils_2.ng)({
                reason: "fileNotFound",
            });
        }
        const nodes = __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_extractNodes).call(this, sourceFile)
            .filter((node) => ts.isExportDeclaration(node) ||
            ts.isEnumDeclaration(node) ||
            ((ts.isInterfaceDeclaration(node) ||
                ts.isTypeAliasDeclaration(node)) &&
                // @ts-expect-error exclude not exported type def
                typeof node?.localSymbol !== "undefined"))
            .filter((node) => __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_isTypeParametersResolved).call(this, __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getTypeAtLocation(node)));
        return (0, utils_2.ok)(nodes
            .flatMap((node) => {
            // export {} from 'path'
            if (ts.isExportDeclaration(node)) {
                const nodes = __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_extractTypesFromExportDeclaration).call(this, node);
                if ((0, utils_2.isOk)(nodes)) {
                    return nodes.ok;
                }
                else {
                    return (0, utils_2.ng)({
                        reason: "exportError",
                        meta: nodes.ng.reason,
                    });
                }
            }
            // export declaration
            return {
                typeName: typeof node?.symbol?.escapedName !== "undefined"
                    ? String(node?.symbol?.escapedName)
                    : undefined,
                type: __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_convertType).call(this, __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getTypeAtLocation(node)),
            };
        })
            .filter((result) => {
            if ("__type" in result && (0, utils_1.isNg)(result)) {
                console.log(`Skip reason: ${result.ng.meta}`);
                return false;
            }
            return true;
        }));
    }
}
exports.CompilerApiHandler = CompilerApiHandler;
_CompilerApiHandler_program = new WeakMap(), _CompilerApiHandler_typeChecker = new WeakMap(), _CompilerApiHandler_instances = new WeakSet(), _CompilerApiHandler_extractTypesFromExportDeclaration = function _CompilerApiHandler_extractTypesFromExportDeclaration(declare) {
    const path = declare.moduleSpecifier?.getText();
    if (!path)
        return (0, utils_2.ng)({
            reason: "fileNotFound",
        });
    const sourceFile = declare.getSourceFile();
    const moduleMap = 
    // @ts-expect-error: type def wrong
    sourceFile.resolvedModules;
    if (!moduleMap)
        return (0, utils_2.ng)({
            reason: "resolvedModulesNotFound",
        });
    const module = moduleMap.get(ts.escapeLeadingUnderscores(path.replace(/'/g, "").replace(/"/g, "")));
    if (!module)
        return (0, utils_2.ng)({
            reason: "moduleNotFound",
        });
    const types = this.extractTypes(module.resolvedFileName);
    if ((0, utils_1.isNg)(types))
        return (0, utils_2.ng)({ reason: "moduleFileNotFound" });
    const clause = declare.exportClause;
    if (!clause)
        return (0, utils_2.ng)({
            reason: "unknown",
        });
    if (ts.isNamedExports(clause)) {
        return (0, utils_2.ok)(clause.elements
            .map(({ symbol }) => symbol?.getEscapedName())
            .filter((str) => typeof str !== "undefined")
            .map((str) => ts.unescapeLeadingUnderscores(str))
            .map((key) => types.ok.find(({ typeName }) => typeName === key) ?? {
            typeName: key,
            type: (0, type_object_1.skip)(),
        }));
    }
    return (0, utils_2.ng)({
        reason: "notNamedExport",
    });
}, _CompilerApiHandler_extractNodes = function _CompilerApiHandler_extractNodes(sourceFile) {
    const nodes = [];
    (0, typescript_1.forEachChild)(sourceFile, (node) => {
        nodes.push(node);
    });
    return nodes;
}, _CompilerApiHandler_createObjectType = function _CompilerApiHandler_createObjectType(tsType) {
    return {
        __type: "ObjectTO",
        tsType,
        typeName: __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_typeToString).call(this, tsType),
        getProps: () => __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f")
            .getPropertiesOfType(tsType)
            .map((symbol) => {
            const typeNode = symbol.valueDeclaration?.type;
            const declare = (symbol.declarations ?? [])[0];
            const type = declare
                ? __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getTypeOfSymbolAtLocation(symbol, declare)
                : undefined;
            return {
                propName: String(symbol.escapedName),
                type: typeNode && ts.isArrayTypeNode(typeNode)
                    ? {
                        __type: "ArrayTO",
                        typeName: __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_typeToString).call(this, __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getTypeFromTypeNode(typeNode)),
                        child: __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_extractArrayTFromTypeNode).call(this, typeNode),
                    }
                    : type
                        ? __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_isCallable).call(this, type)
                            ? (0, type_object_1.skip)()
                            : __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_convertType).call(this, type)
                        : {
                            __type: "UnknownTO",
                            kind: "prop",
                        },
            };
        })
            .filter((typeObject) => typeObject.type.__type !== "SkipTO"),
    };
}, _CompilerApiHandler_extractArrayTFromTypeNode = function _CompilerApiHandler_extractArrayTFromTypeNode(typeNode) {
    return __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_convertType).call(this, __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getTypeAtLocation(typeNode.elementType));
}, _CompilerApiHandler_extractArrayT = function _CompilerApiHandler_extractArrayT(type) {
    const maybeArrayT = (type.resolvedTypeArguments ?? [])[0];
    if (type.symbol.getEscapedName() === "Array" &&
        typeof maybeArrayT !== "undefined") {
        return (0, utils_2.ok)(__classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_convertType).call(this, maybeArrayT));
    }
    const maybeNode = type?.node;
    if (!maybeNode) {
        return (0, utils_2.ng)({
            reason: "node_not_defined",
        });
    }
    // Array<T> で定義されているとき
    if (ts.isTypeReferenceNode(maybeNode)) {
        const [typeArg1] = __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_extractTypeArgumentsFromTypeRefNode).call(this, maybeNode);
        return typeof typeArg1 !== "undefined"
            ? (0, utils_2.ok)(typeArg1)
            : (0, utils_2.ng)({
                reason: "cannot_resolve",
            });
    }
    if (!ts.isArrayTypeNode(maybeNode)) {
        return (0, utils_2.ng)({
            reason: "not_array_type_node",
        });
    }
    return (0, utils_2.ok)(__classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_extractArrayTFromTypeNode).call(this, maybeNode));
}, _CompilerApiHandler_extractTypeArguments = function _CompilerApiHandler_extractTypeArguments(type) {
    const maybeTypeRefNode = (type.aliasSymbol?.declarations ?? [])[0]?.type;
    if (!maybeTypeRefNode) {
        return (0, utils_2.ng)({
            reason: "node_not_found",
        });
    }
    if (!ts.isTypeReferenceNode(maybeTypeRefNode)) {
        return (0, utils_2.ng)({
            reason: "not_type_ref_node",
        });
    }
    return (0, utils_2.ok)(__classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_extractTypeArgumentsFromTypeRefNode).call(this, maybeTypeRefNode));
}, _CompilerApiHandler_extractTypeArgumentsFromTypeRefNode = function _CompilerApiHandler_extractTypeArgumentsFromTypeRefNode(node) {
    return Array.from(node.typeArguments ?? []).map((arg) => __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_convertType).call(this, __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getTypeFromTypeNode(arg)));
}, _CompilerApiHandler_hasUnresolvedTypeParameter = function _CompilerApiHandler_hasUnresolvedTypeParameter(type) {
    if (!("typeName" in type)) {
        return type.__type === "TypeParameterTO";
    }
    const deps = type.__type === "ObjectTO"
        ? type.getProps().map((prop) => prop.type)
        : type.__type === "ArrayTO"
            ? [type.child]
            : type.__type === "UnionTO"
                ? type.unions
                : [];
    return deps.reduce((s, t) => s ||
        t.__type === "TypeParameterTO" ||
        ("typeName" in t &&
            t.typeName !== type.typeName &&
            __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_hasUnresolvedTypeParameter).call(this, t)), false);
}, _CompilerApiHandler_convertType = function _CompilerApiHandler_convertType(type) {
    return (0, utils_2.switchExpression)({
        type,
        typeNode: type.node,
        typeText: __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_typeToString).call(this, type),
    })
        .case(({ type }) => type.isUnion(), ({ typeText }) => ({
        __type: "UnionTO",
        typeName: typeText,
        unions: (type?.types ?? []).map((type) => __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_convertType).call(this, type)),
    }))
        .case(({ type }) => type.isTypeParameter(), ({ typeText }) => ({
        __type: "TypeParameterTO",
        name: typeText,
    }))
        .case(({ typeNode }) => typeof typeNode !== "undefined" && ts.isTupleTypeNode(typeNode), ({ typeText, typeNode }) => ({
        __type: "TupleTO",
        typeName: typeText,
        items: typeNode.elements.map((typeNode) => __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_convertType).call(this, __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getTypeFromTypeNode(typeNode))),
    }))
        .case(({ type }) => type.isLiteral(), ({ type }) => ({
        __type: "LiteralTO",
        value: type.value,
    }))
        .case(({ typeText }) => ["true", "false"].includes(typeText), ({ typeText }) => ({
        __type: "LiteralTO",
        value: typeText === "true" ? true : false,
    }))
        .case(({ typeText }) => typeText === "string", () => (0, type_object_1.primitive)("string"))
        .case(({ typeText }) => typeText === "number", () => (0, type_object_1.primitive)("number"))
        .case(({ typeText }) => typeText === "bigint", () => (0, type_object_1.primitive)("bigint"))
        .case(({ typeText }) => typeText === "boolean", () => (0, type_object_1.primitive)("boolean"))
        .case(({ typeText }) => typeText === "null", () => (0, type_object_1.special)("null"))
        .case(({ typeText }) => typeText === "undefined", () => (0, type_object_1.special)("undefined"))
        .case(({ typeText }) => typeText === "void", () => (0, type_object_1.special)("void"))
        .case(({ typeText }) => typeText === "any", () => (0, type_object_1.special)("any"))
        .case(({ typeText }) => typeText === "unknown", () => (0, type_object_1.special)("unknown"))
        .case(({ typeText }) => typeText === "never", () => (0, type_object_1.special)("never"))
        .case(({ typeText }) => typeText === "Date", () => (0, type_object_1.special)("Date"))
        .case(({ type, typeText }) => typeText.endsWith("[]") || type.symbol?.escapedName === "Array", ({ type, typeText }) => ({
        __type: "ArrayTO",
        typeName: typeText,
        child: (() => {
            const resultT = __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_extractArrayT).call(this, type);
            return (0, utils_2.isOk)(resultT)
                ? resultT.ok
                : { __type: "UnknownTO", kind: "arrayT" };
        })(),
    }))
        .case(({ type }) => __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").getPropertiesOfType(type).length !== 0, ({ type }) => __classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_createObjectType).call(this, type))
        .default(({ typeText }) => ({
        __type: "UnknownTO",
        kind: "convert",
        typeText,
    }));
}, _CompilerApiHandler_isCallable = function _CompilerApiHandler_isCallable(type) {
    return (__classPrivateFieldGet(this, _CompilerApiHandler_instances, "m", _CompilerApiHandler_getMembers).call(this, type).findIndex((member) => (0, typescript_1.unescapeLeadingUnderscores)(member.getEscapedName()) === "__call") >= 0);
}, _CompilerApiHandler_getMembers = function _CompilerApiHandler_getMembers(type) {
    const members = [];
    type.getSymbol()?.members?.forEach((memberSymbol) => {
        members.push(memberSymbol);
    });
    return members;
}, _CompilerApiHandler_isTypeParametersResolved = function _CompilerApiHandler_isTypeParametersResolved(type) {
    return ((type.aliasTypeArguments ?? []).length === 0 ||
        // @ts-expect-error: wrong type def
        type.typeParameter !== undefined);
}, _CompilerApiHandler_typeToString = function _CompilerApiHandler_typeToString(type) {
    return __classPrivateFieldGet(this, _CompilerApiHandler_typeChecker, "f").typeToString(type).replace("typeof ", "");
};
